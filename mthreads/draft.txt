class  Thread
{
public:
	static std::string get_thread_name_of_caller();
	static int set_thread_name_of_caller(const std::string& threadName);
public:
	pthread_t getThreadId();
	const std::string& getThreadName();

	int create(const std::string& threadName, CCmThreadManager::TFlag aFlag = CCmThreadManager::TF_JOINABLE );

	int stop();
	int join();


protected:
	ACmThread();
	virtual ~ACmThread();

	ACmThread(const ACmThread &);
	ACmThread &operator=(const ACmThread &);

};












class  ThreadManager  
{
public:

	static CCmThreadManager* instance();
	
	enum TFlag
	{
		TF_NONE = 0,
		TF_JOINABLE = (1 << 0),
		TF_DETACHED = (1 << 1)
	};

	Thread* getThread(const std::string& threadName);

	Thread* createThread(const std::string& threadName, TFlag aFlag = TF_JOINABLE);


public:

	int stopAllThreads();
	
	int joinAllThreads();

	int registerThread(Thread* aThread);

	int unregisterThread(Thread* aThread);


	static bool isCurrentThread(const std::string& threadName);


};















class CM_OS_EXPORT CCmTimeValue  
{
public:
	CCmTimeValue();
	CCmTimeValue(long aSec);
	CCmTimeValue(long aSec, long aUsec);
	CCmTimeValue(const timeval &aTv);
	CCmTimeValue(double aSec);
	
	void Set(long aSec, long aUsec);
	void Set(const timeval &aTv);
	void Set(double aSec);

	long GetSec() const ;
	long GetUsec() const ;

	void SetByTotalMsec(long aMilliseconds);
	long GetTotalInMsec() const;

	void operator += (const CCmTimeValue &aRight);
	void operator -= (const CCmTimeValue &aRight);

	friend CM_OS_EXPORT CCmTimeValue operator + (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT CCmTimeValue operator - (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT int operator < (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT int operator > (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT int operator <= (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT int operator >= (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT int operator == (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);
	friend CM_OS_EXPORT int operator != (const CCmTimeValue &aLeft, const CCmTimeValue &aRight);

	static CCmTimeValue GetTimeOfDay();
	static const CCmTimeValue s_tvZero;
	static const CCmTimeValue s_tvMax;
	
private:
	void Normalize();
	
	long m_lSec;
	long m_lUsec;
};


// inline functions
inline CCmTimeValue::CCmTimeValue()
	: m_lSec(0)
	, m_lUsec(0)
{
}

inline CCmTimeValue::CCmTimeValue(long aSec)
	: m_lSec(aSec)
	, m_lUsec(0)
{
}

inline CCmTimeValue::CCmTimeValue(long aSec, long aUsec)
{
	Set(aSec, aUsec);
}

inline CCmTimeValue::CCmTimeValue(const timeval &aTv)
{
	Set(aTv);
}

inline CCmTimeValue::CCmTimeValue(double aSec)
{
	Set(aSec);
}

inline void CCmTimeValue::Set(long aSec, long aUsec)
{
	m_lSec = aSec;
	m_lUsec = aUsec;
	Normalize();
}

inline void CCmTimeValue::Set(const timeval &aTv)
{
	m_lSec = aTv.tv_sec;
	m_lUsec = aTv.tv_usec;
	Normalize();
}

inline void CCmTimeValue::Set(double aSec)
{
	long l = (long)aSec;
	m_lSec = l;
	m_lUsec = (long)((aSec - (double)l) * CM_ONE_SECOND_IN_USECS);
	Normalize();
}

inline void CCmTimeValue::SetByTotalMsec(long aMilliseconds)
{
	m_lSec = aMilliseconds / 1000;
	m_lUsec = (aMilliseconds - (m_lSec * 1000)) * 1000;
}

inline long CCmTimeValue::GetSec() const 
{
	return m_lSec;
}

inline long CCmTimeValue::GetUsec() const 
{
	return m_lUsec;
}

inline long CCmTimeValue::GetTotalInMsec() const
{
	return m_lSec * 1000 + m_lUsec / 1000;
}


inline CCmTimeValue CCmTimeValue::GetTimeOfDay()
{
	timeval tvCur;
	::gettimeofday(&tvCur, NULL);
	return CCmTimeValue(tvCur);
}


inline int operator > (const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	if (aLeft.GetSec() > aRight.GetSec())
		return 1;
	else if (aLeft.GetSec() == aRight.GetSec() && aLeft.GetUsec() > aRight.GetUsec())
		return 1;
	else
		return 0;
}

inline int operator >= (const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	if (aLeft.GetSec() > aRight.GetSec())
		return 1;
	else if (aLeft.GetSec() == aRight.GetSec() && aLeft.GetUsec() >= aRight.GetUsec())
		return 1;
	else
		return 0;
}

inline int operator < (const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	return !(aLeft >= aRight);
}

inline int operator <= (const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	return aRight >= aLeft;
}

inline int operator == (const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	return aLeft.GetSec() == aRight.GetSec() && 
		   aLeft.GetUsec() == aRight.GetUsec();
}

inline int operator != (const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	return !(aLeft == aRight);
}

inline void CCmTimeValue::operator += (const CCmTimeValue &aRight)
{
	m_lSec = GetSec() + aRight.GetSec();
	m_lUsec = GetUsec() + aRight.GetUsec();
	Normalize();
}

inline void CCmTimeValue::operator -= (const CCmTimeValue &aRight)
{
	m_lSec = GetSec() - aRight.GetSec();
	m_lUsec = GetUsec() - aRight.GetUsec();
	Normalize();
}

inline CCmTimeValue operator + 
(const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	return CCmTimeValue(aLeft.GetSec() + aRight.GetSec(), 
					  aLeft.GetUsec() + aRight.GetUsec());
}

inline CCmTimeValue operator - 
(const CCmTimeValue &aLeft, const CCmTimeValue &aRight)
{
	return CCmTimeValue(aLeft.GetSec() - aRight.GetSec(), 
					  aLeft.GetUsec() - aRight.GetUsec());
}


void CCmTimeValue::Normalize()
{
//	m_lSec += m_lUsec / CM_ONE_SECOND_IN_USECS;
//	m_lUsec %= CM_ONE_SECOND_IN_USECS;
	if (m_lUsec >= CM_ONE_SECOND_IN_USECS) {
		do {
			m_lSec++;
			m_lUsec -= CM_ONE_SECOND_IN_USECS;
		}
		while (m_lUsec >= CM_ONE_SECOND_IN_USECS);
	}
	else if (m_lUsec <= -CM_ONE_SECOND_IN_USECS) {
		do {
			m_lSec--;
			m_lUsec += CM_ONE_SECOND_IN_USECS;
		}
		while (m_lUsec <= -CM_ONE_SECOND_IN_USECS);
	}

	if (m_lSec >= 1 && m_lUsec < 0) {
		m_lSec--;
		m_lUsec += CM_ONE_SECOND_IN_USECS;
	}
	else if (m_lSec < 0 && m_lUsec > 0) {
		m_lSec++;
		m_lUsec -= CM_ONE_SECOND_IN_USECS;
	}
}




////
#ifndef THREAD_POOL_H
#define THREAD_POOL_H

#include <vector>
#include <queue>
#include <memory>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <future>
#include <functional>
#include <stdexcept>

class ThreadPool {
public:
    ThreadPool(size_t);
    template<class F, class... Args>
    auto enqueue(F&& f, Args&&... args) 
        -> std::future<typename std::result_of<F(Args...)>::type>;
    ~ThreadPool();
private:
    // need to keep track of threads so we can join them
    std::vector< std::thread > workers;
    // the task queue
    std::queue< std::function<void()> > tasks;
    
    // synchronization
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};
 
// the constructor just launches some amount of workers
inline ThreadPool::ThreadPool(size_t threads)
    :   stop(false)
{
    for(size_t i = 0;i<threads;++i)
        workers.emplace_back(
            [this]
            {
                for(;;)
                {
                    std::function<void()> task;

                    {
                        std::unique_lock<std::mutex> lock(this->queue_mutex);
                        this->condition.wait(lock,
                            [this]{ return this->stop || !this->tasks.empty(); });
                        if(this->stop && this->tasks.empty())
                            return;
                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }

                    task();
                }
            }
        );
}

// add new work item to the pool
template<class F, class... Args>
auto ThreadPool::enqueue(F&& f, Args&&... args) 
    -> std::future<typename std::result_of<F(Args...)>::type>
{
    using return_type = typename std::result_of<F(Args...)>::type;

    auto task = std::make_shared< std::packaged_task<return_type()> >(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...)
        );
        
    std::future<return_type> res = task->get_future();
    {
        std::unique_lock<std::mutex> lock(queue_mutex);

        // don't allow enqueueing after stopping the pool
        if(stop)
            throw std::runtime_error("enqueue on stopped ThreadPool");

        tasks.emplace([task](){ (*task)(); });
    }
    condition.notify_one();
    return res;
}

// the destructor joins all threads
inline ThreadPool::~ThreadPool()
{
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
    }
    condition.notify_all();
    for(std::thread &worker: workers)
        worker.join();
}

#endif











